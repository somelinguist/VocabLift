(function (e) {
    "use strict";
    var n = 6, t = 4, o = "asc", r = "desc", i = "_ng_field_", l = "_ng_depth_", a = "_ng_hidden_", s = "_ng_column_", c = /CUSTOM_FILTERS/g, g = /COL_FIELD/g, d = /DISPLAY_CELL_TEMPLATE/g, u = /EDITABLE_CELL_TEMPLATE/g, f = /<.+>/;
    e.ng || (e.ng = {}), e.ngGrid = {}, e.ngGrid.i18n = {};
    var p = angular.module("ngGrid.services", []), h = angular.module("ngGrid.directives", []), m = angular.module("ngGrid.filters", []);
    angular.module("ngGrid", ["ngGrid.services", "ngGrid.directives", "ngGrid.filters"]), ng.moveSelectionHandler = function (e, t, o, r) {
        if (void 0 === e.selectionService.selectedItems)return!0;
        var i, l = o.which || o.keyCode, a = !1, s = !1, c = e.selectionService.lastClickedRow.rowIndex;
        if (e.col && (i = e.col.index), 37 != l && 38 != l && 39 != l && 40 != l && 9 != l && 13 != l)return!0;
        if (e.enableCellSelection) {
            9 == l && o.preventDefault();
            var g = e.showSelectionCheckbox ? 1 == e.col.index : 0 == e.col.index, d = 1 == e.$index || 0 == e.$index, u = e.$index == e.renderedColumns.length - 1 || e.$index == e.renderedColumns.length - 2, f = e.col.index == e.columns.length - 1;
            37 == l || 9 == l && o.shiftKey ? (d && (g && 9 == l && o.shiftKey ? (r.$viewport.scrollLeft(r.$canvas.width()), i = e.columns.length - 1, s = !0) : r.$viewport.scrollLeft(r.$viewport.scrollLeft() - e.col.width)), g || (i -= 1)) : (39 == l || 9 == l && !o.shiftKey) && (u && (f && 9 == l && !o.shiftKey ? (r.$viewport.scrollLeft(0), i = e.showSelectionCheckbox ? 1 : 0, a = !0) : r.$viewport.scrollLeft(r.$viewport.scrollLeft() + e.col.width)), f || (i += 1))
        }
        var p;
        p = e.configGroups.length > 0 ? r.rowFactory.parsedData.filter(function (e) {
            return!e.isAggRow
        }) : r.filteredRows;
        var h = 0;
        if (0 != c && (38 == l || 13 == l && o.shiftKey || 9 == l && o.shiftKey && s) ? h = -1 : c != p.length - 1 && (40 == l || 13 == l && !o.shiftKey || 9 == l && a) && (h = 1), h) {
            var m = p[c + h];
            m.beforeSelectionChange(m, o) && (m.continueSelection(o), e.$emit("ngGridEventDigestGridParent"), e.selectionService.lastClickedRow.renderedRowIndex >= e.renderedRows.length - n - 2 ? r.$viewport.scrollTop(r.$viewport.scrollTop() + e.rowHeight) : n + 2 >= e.selectionService.lastClickedRow.renderedRowIndex && r.$viewport.scrollTop(r.$viewport.scrollTop() - e.rowHeight))
        }
        return e.enableCellSelection && setTimeout(function () {
            e.domAccessProvider.focusCellElement(e, e.renderedColumns.indexOf(e.columns[i]))
        }, 3), !1
    }, String.prototype.trim || (String.prototype.trim = function () {
        return this.replace(/^\s+|\s+$/g, "")
    }), Array.prototype.indexOf || (Array.prototype.indexOf = function (e) {
        var n = this.length >>> 0, t = Number(arguments[1]) || 0;
        for (t = 0 > t ? Math.ceil(t) : Math.floor(t), 0 > t && (t += n); n > t; t++)if (t in this && this[t] === e)return t;
        return-1
    }), Array.prototype.filter || (Array.prototype.filter = function (e) {
        var n = Object(this), t = n.length >>> 0;
        if ("function" != typeof e)throw new TypeError;
        for (var o = [], r = arguments[1], i = 0; t > i; i++)if (i in n) {
            var l = n[i];
            e.call(r, l, i, n) && o.push(l)
        }
        return o
    }), m.filter("checkmark", function () {
        return function (e) {
            return e ? "✔" : "✘"
        }
    }), m.filter("ngColumns", function () {
        return function (e) {
            return e.filter(function (e) {
                return!e.isAggCol
            })
        }
    }), p.factory("$domUtilityService", ["$utilityService", function (e) {
        var n = {}, t = {}, o = function () {
            var e = $("<div></div>");
            e.appendTo("body"), e.height(100).width(100).css("position", "absolute").css("overflow", "scroll"), e.append('<div style="height: 400px; width: 400px;"></div>'), n.ScrollH = e.height() - e[0].clientHeight, n.ScrollW = e.width() - e[0].clientWidth, e.empty(), e.attr("style", ""), e.append('<span style="font-family: Verdana, Helvetica, Sans-Serif; font-size: 14px;"><strong>M</strong></span>'), n.LetterW = e.children().first().width(), e.remove()
        };
        return n.eventStorage = {}, n.AssignGridContainers = function (e, t, o) {
            o.$root = $(t), o.$topPanel = o.$root.find(".ngTopPanel"), o.$groupPanel = o.$root.find(".ngGroupPanel"), o.$headerContainer = o.$topPanel.find(".ngHeaderContainer"), e.$headerContainer = o.$headerContainer, o.$headerScroller = o.$topPanel.find(".ngHeaderScroller"), o.$headers = o.$headerScroller.children(), o.$viewport = o.$root.find(".ngViewport"), o.$canvas = o.$viewport.find(".ngCanvas"), o.$footerPanel = o.$root.find(".ngFooterPanel"), e.$watch(function () {
                return o.$viewport.scrollLeft()
            }, function (e) {
                return o.$headerContainer.scrollLeft(e)
            }), n.UpdateGridLayout(e, o)
        }, n.getRealWidth = function (e) {
            var n = 0, t = {visibility: "hidden", display: "block"}, o = e.parents().andSelf().not(":visible");
            return $.swap(o[0], t, function () {
                n = e.outerWidth()
            }), n
        }, n.UpdateGridLayout = function (e, t) {
            var o = t.$viewport.scrollTop();
            t.elementDims.rootMaxW = t.$root.width(), t.$root.is(":hidden") && (t.elementDims.rootMaxW = n.getRealWidth(t.$root)), t.elementDims.rootMaxH = t.$root.height(), t.refreshDomSizes(), e.adjustScrollTop(o, !0)
        }, n.numberOfGrids = 0, n.BuildStyles = function (t, o, r) {
            var i, l = o.config.rowHeight, a = o.$styleSheet, s = o.gridId, c = t.columns, g = 0;
            a || (a = $("#" + s), a[0] || (a = $("<style id='" + s + "' type='text/css' rel='stylesheet' />").appendTo(o.$root))), a.empty();
            var d = t.totalRowWidth();
            i = "." + s + " .ngCanvas { width: " + d + "px; }" + "." + s + " .ngRow { width: " + d + "px; }" + "." + s + " .ngCanvas { width: " + d + "px; }" + "." + s + " .ngHeaderScroller { width: " + (d + n.ScrollH + 2) + "px}";
            for (var u = 0; c.length > u; u++) {
                var f = c[u];
                if (f.visible !== !1) {
                    var p = f.pinned ? o.$viewport.scrollLeft() + g : g;
                    i += "." + s + " .col" + u + " { width: " + f.width + "px; left: " + p + "px; height: " + l + "px }" + "." + s + " .colt" + u + " { width: " + f.width + "px; }", g += f.width
                }
            }
            e.isIe ? a[0].styleSheet.cssText = i : a[0].appendChild(document.createTextNode(i)), o.$styleSheet = a, r && (t.adjustScrollLeft(o.$viewport.scrollLeft()), n.digest(t))
        }, n.setColLeft = function (n, o, r) {
            if (r.$styleSheet) {
                var i = t[n.index];
                i || (i = t[n.index] = RegExp(".col" + n.index + " { width: [0-9]+px; left: [0-9]+px"));
                var l = r.$styleSheet.html(), a = l.replace(i, ".col" + n.index + " { width: " + n.width + "px; left: " + o + "px");
                e.isIe ? setTimeout(function () {
                    r.$styleSheet.html(a)
                }) : r.$styleSheet.html(a)
            }
        }, n.setColLeft.immediate = 1, n.RebuildGrid = function (e, t) {
            n.UpdateGridLayout(e, t), t.config.maintainColumnRatios && t.configureColumnWidths(), e.adjustScrollLeft(t.$viewport.scrollLeft()), n.BuildStyles(e, t, !0)
        }, n.digest = function (e) {
            e.$root.$$phase || e.$digest()
        }, n.ScrollH = 17, n.ScrollW = 17, n.LetterW = 10, o(), n
    }]), p.factory("$sortService", ["$parse", function (e) {
        var n = {};
        return n.colSortFnCache = {}, n.guessSortFn = function (e) {
            var t = typeof e;
            switch (t) {
                case"number":
                    return n.sortNumber;
                case"boolean":
                    return n.sortBool;
                case"string":
                    return e.match(/^-?[£$¤]?[\d,.]+%?$/) ? n.sortNumberStr : n.sortAlpha;
                default:
                    return"[object Date]" === Object.prototype.toString.call(e) ? n.sortDate : n.basicSort
            }
        }, n.basicSort = function (e, n) {
            return e == n ? 0 : n > e ? -1 : 1
        }, n.sortNumber = function (e, n) {
            return e - n
        }, n.sortNumberStr = function (e, n) {
            var t, o, r = !1, i = !1;
            return t = parseFloat(e.replace(/[^0-9.-]/g, "")), isNaN(t) && (r = !0), o = parseFloat(n.replace(/[^0-9.-]/g, "")), isNaN(o) && (i = !0), r && i ? 0 : r ? 1 : i ? -1 : t - o
        }, n.sortAlpha = function (e, n) {
            var t = e.toLowerCase(), o = n.toLowerCase();
            return t == o ? 0 : o > t ? -1 : 1
        }, n.sortDate = function (e, n) {
            var t = e.getTime(), o = n.getTime();
            return t == o ? 0 : o > t ? -1 : 1
        }, n.sortBool = function (e, n) {
            return e && n ? 0 : e || n ? e ? 1 : -1 : 0
        }, n.sortData = function (t, r) {
            if (r && t) {
                var i, l, a = t.fields.length, s = t.fields, c = r.slice(0);
                r.sort(function (r, g) {
                    for (var d, u = 0, f = 0; 0 == u && a > f;) {
                        i = t.columns[f], l = t.directions[f], d = n.getSortFn(i, c);
                        var p = e(s[f])(r), h = e(s[f])(g);
                        !p && 0 != p || !h && 0 != h ? h || p ? p ? h || (u = -1) : u = 1 : u = 0 : u = d(p, h), f++
                    }
                    return l === o ? u : 0 - u
                })
            }
        }, n.Sort = function (e, t) {
            n.isSorting || (n.isSorting = !0, n.sortData(e, t), n.isSorting = !1)
        }, n.getSortFn = function (t, o) {
            var r, i = void 0;
            if (n.colSortFnCache[t.field])i = n.colSortFnCache[t.field]; else if (void 0 != t.sortingAlgorithm)i = t.sortingAlgorithm, n.colSortFnCache[t.field] = t.sortingAlgorithm; else {
                if (r = o[0], !r)return i;
                i = n.guessSortFn(e(t.field)(r)), i ? n.colSortFnCache[t.field] = i : i = n.sortAlpha
            }
            return i
        }, n
    }]), p.factory("$utilityService", ["$parse", function (n) {
        var t = {visualLength: function (e) {
            var n = document.getElementById("testDataLength");
            return n || (n = document.createElement("SPAN"), n.id = "testDataLength", n.style.visibility = "hidden", document.body.appendChild(n)), $(n).css("font", $(e).css("font")), n.innerHTML = $(e).text(), n.offsetWidth
        }, forIn: function (e, n) {
            for (var t in e)e.hasOwnProperty(t) && n(e[t], t)
        }, evalProperty: function (e, t) {
            return n(t)(e)
        }, endsWith: function (e, n) {
            return e && n && "string" == typeof e ? -1 !== e.indexOf(n, e.length - n.length) : !1
        }, isNullOrUndefined: function (e) {
            return void 0 === e || null === e ? !0 : !1
        }, getElementsByClassName: function (e) {
            for (var n = [], t = RegExp("\\b" + e + "\\b"), o = document.getElementsByTagName("*"), r = 0; o.length > r; r++) {
                var i = o[r].className;
                t.test(i) && n.push(o[r])
            }
            return n
        }, newId: function () {
            var e = (new Date).getTime();
            return function () {
                return e += 1
            }
        }(), seti18n: function (n, t) {
            var o = e.ngGrid.i18n[t];
            for (var r in o)n.i18n[r] = o[r]
        }, ieVersion: function () {
            for (var e = 3, n = document.createElement("div"), t = n.getElementsByTagName("i"); n.innerHTML = "<!--[if gt IE " + ++e + "]><i></i><![endif]-->", t[0];);
            return e > 4 ? e : void 0
        }()};
        return $.extend(t, {isIe: function () {
            return void 0 !== t.ieVersion
        }()}), t
    }]), ng.Aggregate = function (e, n, t) {
        var o = this;
        o.rowIndex = 0, o.offsetTop = o.rowIndex * t, o.entity = e, o.label = e.gLabel, o.field = e.gField, o.depth = e.gDepth, o.parent = e.parent, o.children = e.children, o.aggChildren = e.aggChildren, o.aggIndex = e.aggIndex, o.collapsed = !0, o.isAggRow = !0, o.offsetleft = 25 * e.gDepth, o.aggLabelFilter = e.aggLabelFilter, o.toggleExpand = function () {
            o.collapsed = o.collapsed ? !1 : !0, o.orig && (o.orig.collapsed = o.collapsed), o.notifyChildren()
        }, o.setExpand = function (e) {
            o.collapsed = e, o.notifyChildren()
        }, o.notifyChildren = function () {
            for (var e = Math.max(n.aggCache.length, o.children.length), t = 0; e > t; t++)if (o.aggChildren[t] && (o.aggChildren[t].entity[a] = o.collapsed, o.collapsed && o.aggChildren[t].setExpand(o.collapsed)), o.children[t] && (o.children[t][a] = o.collapsed), t > o.aggIndex && n.aggCache[t]) {
                var r = n.aggCache[t], i = 30 * o.children.length;
                r.offsetTop = o.collapsed ? r.offsetTop - i : r.offsetTop + i
            }
            n.renderedChange()
        }, o.aggClass = function () {
            return o.collapsed ? "ngAggArrowCollapsed" : "ngAggArrowExpanded"
        }, o.totalChildren = function () {
            if (o.aggChildren.length > 0) {
                var e = 0, n = function (t) {
                    t.aggChildren.length > 0 ? angular.forEach(t.aggChildren, function (e) {
                        n(e)
                    }) : e += t.children.length
                };
                return n(o), e
            }
            return o.children.length
        }, o.copy = function () {
            var e = new ng.Aggregate(o.entity, n, t);
            return e.orig = o, e
        }
    }, ng.Column = function (e, n, t, i, l, a) {
        var s = this, g = e.colDef, d = 500, u = 0, p = null;
        s.width = g.width, s.groupIndex = 0, s.isGroupedBy = !1, s.minWidth = g.minWidth ? g.minWidth : 50, s.maxWidth = g.maxWidth ? g.maxWidth : 9e3, s.enableCellEdit = e.enableCellEdit || g.enableCellEdit, s.headerRowHeight = e.headerRowHeight, s.displayName = g.displayName || g.field, s.index = e.index, s.isAggCol = e.isAggCol, s.cellClass = g.cellClass, s.sortPriority = void 0, s.zIndex = function () {
            return s.pinned ? 5 : 0
        }, s.cellFilter = g.cellFilter ? g.cellFilter : "", s.field = g.field, s.aggLabelFilter = g.cellFilter || g.aggLabelFilter, s.visible = a.isNullOrUndefined(g.visible) || g.visible, s.sortable = !1, s.resizable = !1, s.pinnable = !1, s.pinned = g.pinned, s.originalIndex = s.index, s.groupable = a.isNullOrUndefined(g.groupable) || g.groupable, e.enableSort && (s.sortable = a.isNullOrUndefined(g.sortable) || g.sortable), e.enableResize && (s.resizable = a.isNullOrUndefined(g.resizable) || g.resizable), e.enablePinning && (s.pinnable = a.isNullOrUndefined(g.pinnable) || g.pinnable), s.sortDirection = void 0, s.sortingAlgorithm = g.sortFn, s.headerClass = g.headerClass, s.cursor = s.sortable ? "pointer" : "default", s.headerCellTemplate = g.headerCellTemplate || l.get("headerCellTemplate.html"), s.cellTemplate = g.cellTemplate || l.get("cellTemplate.html").replace(c, s.cellFilter ? "|" + s.cellFilter : ""), s.enableCellEdit && (s.cellEditTemplate = l.get("cellEditTemplate.html"), s.editableCellTemplate = g.editableCellTemplate || l.get("editableCellTemplate.html")), g.cellTemplate && !f.test(g.cellTemplate) && (s.cellTemplate = $.ajax({type: "GET", url: g.cellTemplate, async: !1}).responseText), s.enableCellEdit && g.editableCellTemplate && !f.test(g.editableCellTemplate) && (s.editableCellTemplate = $.ajax({type: "GET", url: g.editableCellTemplate, async: !1}).responseText), g.headerCellTemplate && !f.test(g.headerCellTemplate) && (s.headerCellTemplate = $.ajax({type: "GET", url: g.headerCellTemplate, async: !1}).responseText), s.colIndex = function () {
            return"col" + s.index + " colt" + s.index
        }, s.groupedByClass = function () {
            return s.isGroupedBy ? "ngGroupedByIcon" : "ngGroupIcon"
        }, s.toggleVisible = function () {
            s.visible = !s.visible
        }, s.showSortButtonUp = function () {
            return s.sortable ? s.sortDirection === r : s.sortable
        }, s.showSortButtonDown = function () {
            return s.sortable ? s.sortDirection === o : s.sortable
        }, s.noSortVisible = function () {
            return!s.sortDirection
        }, s.sort = function (n) {
            if (!s.sortable)return!0;
            var t = s.sortDirection === o ? r : o;
            return s.sortDirection = t, e.sortCallback(s, n), !1
        }, s.gripClick = function () {
            u++, 1 === u ? p = setTimeout(function () {
                u = 0
            }, d) : (clearTimeout(p), e.resizeOnDataCallback(s), u = 0)
        }, s.gripOnMouseDown = function (e) {
            return e.ctrlKey && !s.pinned ? (s.toggleVisible(), i.BuildStyles(n, t), !0) : (e.target.parentElement.style.cursor = "col-resize", s.startMousePosition = e.clientX, s.origWidth = s.width, $(document).mousemove(s.onMouseMove), $(document).mouseup(s.gripOnMouseUp), !1)
        }, s.onMouseMove = function (e) {
            var o = e.clientX - s.startMousePosition, r = o + s.origWidth;
            return s.width = s.minWidth > r ? s.minWidth : r > s.maxWidth ? s.maxWidth : r, i.BuildStyles(n, t), !1
        }, s.gripOnMouseUp = function (e) {
            return $(document).off("mousemove", s.onMouseMove), $(document).off("mouseup", s.gripOnMouseUp), e.target.parentElement.style.cursor = "default", n.adjustScrollLeft(0), i.digest(n), !1
        }, s.copy = function () {
            var o = new ng.Column(e, n, t, i, l);
            return o.isClone = !0, o.orig = s, o
        }, s.setVars = function (e) {
            s.orig = e, s.width = e.width, s.groupIndex = e.groupIndex, s.isGroupedBy = e.isGroupedBy, s.displayName = e.displayName, s.index = e.index, s.isAggCol = e.isAggCol, s.cellClass = e.cellClass, s.cellFilter = e.cellFilter, s.field = e.field, s.aggLabelFilter = e.aggLabelFilter, s.visible = e.visible, s.sortable = e.sortable, s.resizable = e.resizable, s.pinnable = e.pinnable, s.pinned = e.pinned, s.originalIndex = e.originalIndex, s.sortDirection = e.sortDirection, s.sortingAlgorithm = e.sortingAlgorithm, s.headerClass = e.headerClass, s.headerCellTemplate = e.headerCellTemplate, s.cellTemplate = e.cellTemplate, s.cellEditTemplate = e.cellEditTemplate
        }
    }, ng.Dimension = function (e) {
        this.outerHeight = null, this.outerWidth = null, $.extend(this, e)
    }, ng.DomAccessProvider = function (e) {
        var n, t = this;
        t.selectInputElement = function (e) {
            var n = e.nodeName.toLowerCase();
            ("input" == n || "textarea" == n) && e.select()
        }, t.focusCellElement = function (t, o) {
            if (t.selectionProvider.lastClickedRow) {
                var r = void 0 != o ? o : n, i = t.selectionProvider.lastClickedRow.clone ? t.selectionProvider.lastClickedRow.clone.elm : t.selectionProvider.lastClickedRow.elm;
                if (void 0 != r && i) {
                    var l = angular.element(i[0].children).filter(function () {
                        return 8 != this.nodeType
                    }), a = Math.max(Math.min(t.renderedColumns.length - 1, r), 0);
                    e.config.showSelectionCheckbox && angular.element(l[a]).scope() && 0 == angular.element(l[a]).scope().col.index && (a = 1), l[a] && l[a].children[0].focus(), n = r
                }
            }
        };
        var o = function (e, n) {
            e.css({"-webkit-touch-callout": n, "-webkit-user-select": n, "-khtml-user-select": n, "-moz-user-select": "none" == n ? "-moz-none" : n, "-ms-user-select": n, "user-select": n})
        };
        t.selectionHandlers = function (n, t) {
            var r = !1;
            t.bind("keydown", function (i) {
                if (16 == i.keyCode)return o(t, "none", i), !0;
                if (!r) {
                    r = !0;
                    var l = ng.moveSelectionHandler(n, t, i, e);
                    return r = !1, l
                }
                return!0
            }), t.bind("keyup", function (e) {
                return 16 == e.keyCode && o(t, "text", e), !0
            })
        }
    }, ng.EventProvider = function (n, t, o) {
        var r = this;
        r.colToMove = void 0, r.groupToMove = void 0, r.assignEvents = function () {
            n.config.jqueryUIDraggable && !n.config.enablePinning ? (n.$groupPanel.droppable({addClasses: !1, drop: function (e) {
                r.onGroupDrop(e)
            }}), t.$evalAsync(r.setDraggables)) : (n.$groupPanel.on("mousedown", r.onGroupMouseDown).on("dragover", r.dragOver).on("drop", r.onGroupDrop), n.$headerScroller.on("mousedown", r.onHeaderMouseDown).on("dragover", r.dragOver), n.config.enableColumnReordering && !n.config.enablePinning && n.$headerScroller.on("drop", r.onHeaderDrop), n.config.enableRowReordering && n.$viewport.on("mousedown", r.onRowMouseDown).on("dragover", r.dragOver).on("drop", r.onRowDrop)), t.$watch("columns", r.setDraggables, !0)
        }, r.dragStart = function (e) {
            e.dataTransfer.setData("text", "")
        }, r.dragOver = function (e) {
            e.preventDefault()
        }, r.setDraggables = function () {
            if (n.config.jqueryUIDraggable)n.$root.find(".ngHeaderSortColumn").draggable({helper: "clone", appendTo: "body", stack: "div", addClasses: !1, start: function (e) {
                r.onHeaderMouseDown(e)
            }}).droppable({drop: function (e) {
                r.onHeaderDrop(e)
            }}); else {
                var e = n.$root.find(".ngHeaderSortColumn");
                angular.forEach(e, function (e) {
                    e.setAttribute("draggable", "true"), e.addEventListener && e.addEventListener("dragstart", r.dragStart)
                }), -1 != navigator.userAgent.indexOf("MSIE") && n.$root.find(".ngHeaderSortColumn").bind("selectstart", function () {
                    return this.dragDrop(), !1
                })
            }
        }, r.onGroupMouseDown = function (e) {
            var t = $(e.target);
            if ("ngRemoveGroup" != t[0].className) {
                var o = angular.element(t).scope();
                o && (n.config.jqueryUIDraggable || (t.attr("draggable", "true"), this.addEventListener && this.addEventListener("dragstart", r.dragStart), -1 != navigator.userAgent.indexOf("MSIE") && t.bind("selectstart", function () {
                    return this.dragDrop(), !1
                })), r.groupToMove = {header: t, groupName: o.group, index: o.$index})
            } else r.groupToMove = void 0
        }, r.onGroupDrop = function (e) {
            e.stopPropagation();
            var o, i;
            r.groupToMove ? (o = $(e.target).closest(".ngGroupElement"), "ngGroupPanel" == o.context.className ? (t.configGroups.splice(r.groupToMove.index, 1), t.configGroups.push(r.groupToMove.groupName)) : (i = angular.element(o).scope(), i && r.groupToMove.index != i.$index && (t.configGroups.splice(r.groupToMove.index, 1), t.configGroups.splice(i.$index, 0, r.groupToMove.groupName))), r.groupToMove = void 0, n.fixGroupIndexes()) : r.colToMove && (-1 == t.configGroups.indexOf(r.colToMove.col) && (o = $(e.target).closest(".ngGroupElement"), "ngGroupPanel" == o.context.className || "ngGroupPanelDescription ng-binding" == o.context.className ? t.groupBy(r.colToMove.col) : (i = angular.element(o).scope(), i && t.removeGroup(i.$index))), r.colToMove = void 0), t.$$phase || t.$apply()
        }, r.onHeaderMouseDown = function (e) {
            var n = $(e.target).closest(".ngHeaderSortColumn"), t = angular.element(n).scope();
            t && (r.colToMove = {header: n, col: t.col})
        }, r.onHeaderDrop = function (e) {
            if (r.colToMove) {
                var i = $(e.target).closest(".ngHeaderSortColumn"), l = angular.element(i).scope();
                if (l) {
                    if (r.colToMove.col == l.col)return;
                    t.columns.splice(r.colToMove.col.index, 1), t.columns.splice(l.col.index, 0, r.colToMove.col), n.fixColumnIndexes(), o.BuildStyles(t, n, !0), r.colToMove = void 0
                }
            }
        }, r.onRowMouseDown = function (e) {
            var n = $(e.target).closest(".ngRow"), t = angular.element(n).scope();
            t && (n.attr("draggable", "true"), o.eventStorage.rowToMove = {targetRow: n, scope: t})
        }, r.onRowDrop = function (e) {
            var t = $(e.target).closest(".ngRow"), r = angular.element(t).scope();
            if (r) {
                var i = o.eventStorage.rowToMove;
                if (i.scope.row == r.row)return;
                n.changeRowOrder(i.scope.row, r.row), n.searchProvider.evalFilter(), o.eventStorage.rowToMove = void 0, o.digest(r.$root)
            }
        }, r.assignGridEventHandlers = function () {
            -1 === n.config.tabIndex ? (n.$viewport.attr("tabIndex", o.numberOfGrids), o.numberOfGrids++) : n.$viewport.attr("tabIndex", n.config.tabIndex), $(e).resize(function () {
                o.RebuildGrid(t, n)
            })
        }, r.assignGridEventHandlers(), r.assignEvents()
    }, ng.Footer = function (e, n) {
        e.maxRows = function () {
            var t = Math.max(e.pagingOptions.totalServerItems, n.data.length);
            return t
        }, e.multiSelect = n.config.enableRowSelection && n.config.multiSelect, e.selectedItemCount = n.selectedItemCount, e.maxPages = function () {
            return Math.ceil(e.maxRows() / e.pagingOptions.pageSize)
        }, e.pageForward = function () {
            var n = e.pagingOptions.currentPage;
            e.pagingOptions.totalServerItems > 0 ? e.pagingOptions.currentPage = Math.min(n + 1, e.maxPages()) : e.pagingOptions.currentPage++
        }, e.pageBackward = function () {
            var n = e.pagingOptions.currentPage;
            e.pagingOptions.currentPage = Math.max(n - 1, 1)
        }, e.pageToFirst = function () {
            e.pagingOptions.currentPage = 1
        }, e.pageToLast = function () {
            var n = e.maxPages();
            e.pagingOptions.currentPage = n
        }, e.cantPageForward = function () {
            var t = e.pagingOptions.currentPage, o = e.maxPages();
            return e.pagingOptions.totalServerItems > 0 ? !(o > t) : 1 > n.data.length
        }, e.cantPageToLast = function () {
            return e.pagingOptions.totalServerItems > 0 ? e.cantPageForward() : !0
        }, e.cantPageBackward = function () {
            var n = e.pagingOptions.currentPage;
            return!(n > 1)
        }
    }, ng.Grid = function (o, r, i, l, s, c, g, d) {
        var u = {aggregateTemplate: void 0, afterSelectionChange: function () {
        }, beforeSelectionChange: function () {
            return!0
        }, checkboxCellTemplate: void 0, checkboxHeaderTemplate: void 0, columnDefs: void 0, data: [], dataUpdated: function () {
        }, enableCellEdit: !1, enableCellSelection: !1, enableColumnResize: !1, enableColumnReordering: !1, enableColumnHeavyVirt: !1, enablePaging: !1, enablePinning: !1, enableRowReordering: !1, enableRowSelection: !0, enableSorting: !0, excludeProperties: [], filterOptions: {filterText: "", useExternalFilter: !1}, footerRowHeight: 55, groups: [], headerRowHeight: 30, headerRowTemplate: void 0, jqueryUIDraggable: !1, jqueryUITheme: !1, keepLastSelected: !0, maintainColumnRatios: void 0, multiSelect: !0, pagingOptions: {pageSizes: [250, 500, 1e3], pageSize: 250, totalServerItems: 0, currentPage: 1}, pinSelectionCheckbox: !1, plugins: [], rowHeight: 30, rowTemplate: void 0, selectedItems: [], selectWithCheckboxOnly: !1, showColumnMenu: !1, showFilter: !1, showFooter: !1, showGroupPanel: !1, showSelectionCheckbox: !1, sortInfo: {fields: [], columns: [], directions: []}, tabIndex: -1, useExternalSorting: !1, i18n: "en", virtualizationThreshold: 50}, p = this;
        p.maxCanvasHt = 0, p.config = $.extend(u, e.ngGrid.config, r), p.config.showSelectionCheckbox = p.config.showSelectionCheckbox && p.config.enableColumnHeavyVirt === !1, p.config.enablePinning = p.config.enablePinning && p.config.enableColumnHeavyVirt === !1, p.config.selectWithCheckboxOnly = p.config.selectWithCheckboxOnly && p.config.showSelectionCheckbox !== !1, p.config.pinSelectionCheckbox = p.config.enablePinning, "string" == typeof r.columnDefs && (p.config.columnDefs = o.$eval(r.columnDefs)), p.rowCache = [], p.rowMap = [], p.gridId = "ng" + g.newId(), p.$root = null, p.$groupPanel = null, p.$topPanel = null, p.$headerContainer = null, p.$headerScroller = null, p.$headers = null, p.$viewport = null, p.$canvas = null, p.rootDim = p.config.gridDim, p.data = [], p.lateBindColumns = !1, p.filteredRows = [];
        var h = function (e) {
            var n = p.config[e], t = p.gridId + e + ".html";
            if (n && !f.test(n))c.put(t, $.ajax({type: "GET", url: n, async: !1}).responseText); else if (n)c.put(t, n); else {
                var o = e + ".html";
                c.put(t, c.get(o))
            }
        };
        h("rowTemplate"), h("aggregateTemplate"), h("headerRowTemplate"), h("checkboxCellTemplate"), h("checkboxHeaderTemplate"), "object" == typeof p.config.data && (p.data = p.config.data), p.calcMaxCanvasHeight = function () {
            return p.config.groups.length > 0 ? p.rowFactory.parsedData.filter(function (e) {
                return!e[a]
            }).length * p.config.rowHeight : p.filteredRows.length * p.config.rowHeight
        }, p.elementDims = {scrollW: 0, scrollH: 0, rowIndexCellW: 25, rowSelectedCellW: 25, rootMaxW: 0, rootMaxH: 0}, p.setRenderedRows = function (e) {
            o.renderedRows.length = e.length;
            for (var n = 0; e.length > n; n++)!o.renderedRows[n] || e[n].isAggRow || o.renderedRows[n].isAggRow ? (o.renderedRows[n] = e[n].copy(), o.renderedRows[n].collapsed = e[n].collapsed, e[n].isAggRow || o.renderedRows[n].setVars(e[n])) : o.renderedRows[n].setVars(e[n]), o.renderedRows[n].rowIndex = e[n].rowIndex, o.renderedRows[n].offsetTop = e[n].offsetTop, e[n].renderedRowIndex = n;
            p.refreshDomSizes(), o.$emit("ngGridEventRows", e)
        }, p.minRowsToRender = function () {
            var e = o.viewportDimHeight() || 1;
            return Math.floor(e / p.config.rowHeight)
        }, p.refreshDomSizes = function () {
            var e = new ng.Dimension;
            e.outerWidth = p.elementDims.rootMaxW, e.outerHeight = p.elementDims.rootMaxH, p.rootDim = e, p.maxCanvasHt = p.calcMaxCanvasHeight()
        }, p.buildColumnDefsFromData = function () {
            p.config.columnDefs = [];
            var e = p.data[0];
            return e ? (g.forIn(e, function (e, n) {
                -1 == p.config.excludeProperties.indexOf(n) && p.config.columnDefs.push({field: n})
            }), void 0) : (p.lateBoundColumns = !0, void 0)
        }, p.buildColumns = function () {
            var e = p.config.columnDefs, n = [];
            if (e || (p.buildColumnDefsFromData(), e = p.config.columnDefs), p.config.showSelectionCheckbox && n.push(new ng.Column({colDef: {field: "✔", width: p.elementDims.rowSelectedCellW, sortable: !1, resizable: !1, groupable: !1, headerCellTemplate: c.get(o.gridId + "checkboxHeaderTemplate.html"), cellTemplate: c.get(o.gridId + "checkboxCellTemplate.html"), pinned: p.config.pinSelectionCheckbox}, index: 0, headerRowHeight: p.config.headerRowHeight, sortCallback: p.sortData, resizeOnDataCallback: p.resizeOnData, enableResize: p.config.enableColumnResize, enableSort: p.config.enableSorting}, o, p, l, c, g)), e.length > 0) {
                var t = p.config.showSelectionCheckbox ? p.config.groups.length + 1 : p.config.groups.length;
                o.configGroups.length = 0, angular.forEach(e, function (e, r) {
                    r += t;
                    var i = new ng.Column({colDef: e, index: r, headerRowHeight: p.config.headerRowHeight, sortCallback: p.sortData, resizeOnDataCallback: p.resizeOnData, enableResize: p.config.enableColumnResize, enableSort: p.config.enableSorting, enablePinning: p.config.enablePinning, enableCellEdit: p.config.enableCellEdit}, o, p, l, c, g), a = p.config.groups.indexOf(e.field);
                    -1 != a && (i.isGroupedBy = !0, o.configGroups.splice(a, 0, i), i.groupIndex = o.configGroups.length), n.push(i)
                }), o.columns = n
            }
        }, p.configureColumnWidths = function () {
            var e = p.config.columnDefs, n = p.config.showSelectionCheckbox ? o.configGroups.length + 1 : o.configGroups.length, t = e.length + n, r = [], i = [], a = 0, s = 0;
            if (s += p.config.showSelectionCheckbox ? 25 : 0, angular.forEach(e, function (e, t) {
                t += n;
                var l = !1, c = void 0;
                if (g.isNullOrUndefined(e.width) ? e.width = "*" : (l = isNaN(e.width) ? g.endsWith(e.width, "%") : !1, c = l ? e.width : parseInt(e.width, 10)), isNaN(c)) {
                    if (c = e.width, "auto" == c) {
                        o.columns[t].width = e.minWidth, s += o.columns[t].width;
                        var u = o.columns[t];
                        return d(function () {
                            p.resizeOnData(u, !0)
                        }), void 0
                    }
                    if (-1 != c.indexOf("*"))return e.visible !== !1 && (a += c.length), e.index = t, r.push(e), void 0;
                    if (l)return e.index = t, i.push(e), void 0;
                    throw'unable to parse column width, use percentage ("10%","20%", etc...) or "*" to use remaining width of grid'
                }
                e.visible !== !1 && (s += o.columns[t].width = parseInt(e.width, 10))
            }), r.length > 0) {
                p.config.maintainColumnRatios === !1 ? angular.noop() : p.config.maintainColumnRatios = !0;
                var c = p.rootDim.outerWidth - s, u = Math.floor(c / a);
                angular.forEach(r, function (e) {
                    var n = e.width.length;
                    if (o.columns[e.index].width = u * n, e.index + 1 == t) {
                        var r = 2;
                        p.maxCanvasHt > o.viewportDimHeight() && (r += l.ScrollW), o.columns[e.index].width -= r
                    }
                    e.visible !== !1 && (s += o.columns[e.index].width)
                })
            }
            i.length > 0 && angular.forEach(i, function (e) {
                var n = e.width;
                o.columns[e.index].width = Math.floor(p.rootDim.outerWidth * (parseInt(n.slice(0, -1), 10) / 100))
            })
        }, p.init = function () {
            o.selectionProvider = new ng.selectionProvider(p, o), o.domAccessProvider = new ng.DomAccessProvider(p), p.rowFactory = new ng.RowFactory(p, o, l, c, g), p.searchProvider = new ng.SearchProvider(o, p, s), p.styleProvider = new ng.StyleProvider(o, p, l), o.$watch("configGroups", function (e) {
                var n = [];
                angular.forEach(e, function (e) {
                    n.push(e.field || e)
                }), p.config.groups = n, p.rowFactory.filteredRowsChanged(), o.$emit("ngGridEventGroups", e)
            }, !0), o.$watch("columns", function (e) {
                l.BuildStyles(o, p, !0), o.$emit("ngGridEventColumns", e)
            }, !0), o.$watch(function () {
                return r.i18n
            }, function (e) {
                g.seti18n(o, e)
            }), p.maxCanvasHt = p.calcMaxCanvasHeight(), p.config.sortInfo.fields && p.config.sortInfo.fields.length > 0 && (p.config.sortInfo.columns ? p.config.sortInfo.columns.length = 0 : p.config.sortInfo.columns = [], angular.forEach(o.columns, function (e) {
                return-1 != p.config.sortInfo.fields.indexOf(e.field) && p.config.sortInfo.columns.push(e), !1
            }), p.sortData(p.config.sortInfo.columns, {}))
        }, p.resizeOnData = function (e) {
            var n = e.minWidth, t = g.getElementsByClassName("col" + e.index);
            angular.forEach(t, function (e, t) {
                var o;
                if (0 === t) {
                    var r = $(e).find(".ngHeaderText");
                    o = g.visualLength(r) + 10
                } else {
                    var i = $(e).find(".ngCellText");
                    o = g.visualLength(i) + 10
                }
                o > n && (n = o)
            }), e.width = e.longest = Math.min(e.maxWidth, n + 7), l.BuildStyles(o, p, !0)
        }, p.lastSortedColumns = [], p.changeRowOrder = function (e, n) {
            var t = p.rowCache.indexOf(e), r = p.rowCache.indexOf(n);
            p.rowCache.splice(t, 1), p.rowCache.splice(r, 0, e), o.$emit("ngGridEventChangeOrder", p.rowCache)
        }, p.sortData = function (e, n) {
            if (n.shiftKey && p.config.sortInfo) {
                var t = p.config.sortInfo.columns.indexOf(e);
                -1 === t ? (1 == p.config.sortInfo.columns.length && (p.config.sortInfo.columns[0].sortPriority = 1), p.config.sortInfo.columns.push(e), e.sortPriority = p.config.sortInfo.columns.length, p.config.sortInfo.fields.push(e.field), p.config.sortInfo.directions.push(e.sortDirection), p.lastSortedColumns.push(e)) : p.config.sortInfo.directions[t] = e.sortDirection
            } else {
                var r = $.isArray(e);
                p.config.sortInfo.columns.length = 0, p.config.sortInfo.fields.length = 0, p.config.sortInfo.directions.length = 0;
                var l = function (e) {
                    p.config.sortInfo.columns.push(e), p.config.sortInfo.fields.push(e.field), p.config.sortInfo.directions.push(e.sortDirection), p.lastSortedColumns.push(e)
                };
                r ? (p.clearSortingData(), angular.forEach(e, function (e, n) {
                    e.sortPriority = n + 1, l(e)
                })) : (p.clearSortingData(e), e.sortPriority = void 0, l(e))
            }
            if (!p.config.useExternalSorting) {
                var a = p.data.slice(0);
                angular.forEach(a, function (e, n) {
                    e.preSortSelected = p.rowCache[p.rowMap[n]].selected, e.preSortIndex = n
                }), i.Sort(p.config.sortInfo, a), angular.forEach(a, function (e, n) {
                    p.rowCache[n].entity = e, p.rowCache[n].selected = e.preSortSelected, p.rowMap[e.preSortIndex] = n, delete e.preSortSelected, delete e.preSortIndex
                })
            }
            p.searchProvider.evalFilter(), o.$emit("ngGridEventSorted", p.config.sortInfo)
        }, p.clearSortingData = function (e) {
            e ? (angular.forEach(p.lastSortedColumns, function (n) {
                e.index != n.index && (n.sortDirection = "", n.sortPriority = null)
            }), p.lastSortedColumns[0] = e, p.lastSortedColumns.length = 1) : (angular.forEach(p.lastSortedColumns, function (e) {
                e.sortDirection = "", e.sortPriority = null
            }), p.lastSortedColumns = [])
        }, p.fixColumnIndexes = function () {
            for (var e = 0; o.columns.length > e; e++)o.columns[e].visible !== !1 && (o.columns[e].index = e)
        }, p.fixGroupIndexes = function () {
            angular.forEach(o.configGroups, function (e, n) {
                e.groupIndex = n + 1
            })
        }, o.elementsNeedMeasuring = !0, o.columns = [], o.renderedRows = [], o.renderedColumns = [], o.headerRow = null, o.rowHeight = p.config.rowHeight, o.jqueryUITheme = p.config.jqueryUITheme, o.showSelectionCheckbox = p.config.showSelectionCheckbox, o.enableCellSelection = p.config.enableCellSelection, o.footer = null, o.selectedItems = p.config.selectedItems, o.multiSelect = p.config.multiSelect, o.showFooter = p.config.showFooter, o.footerRowHeight = o.showFooter ? p.config.footerRowHeight : 0, o.showColumnMenu = p.config.showColumnMenu, o.showMenu = !1, o.configGroups = [], o.gridId = p.gridId, o.enablePaging = p.config.enablePaging, o.pagingOptions = p.config.pagingOptions, o.i18n = {}, g.seti18n(o, p.config.i18n), o.adjustScrollLeft = function (e) {
            for (var n = 0, t = 0, r = o.columns.length, i = [], a = !p.config.enableColumnHeavyVirt, s = 0, c = function (e) {
                a ? i.push(e) : o.renderedColumns[s] ? o.renderedColumns[s].setVars(e) : o.renderedColumns[s] = e.copy(), s++
            }, g = 0; r > g; g++) {
                var d = o.columns[g];
                if (d.visible !== !1) {
                    var u = d.width + n;
                    if (d.pinned) {
                        c(d);
                        var f = g > 0 ? e + t : e;
                        l.setColLeft(d, f, p), t += d.width
                    } else u >= e && e + p.rootDim.outerWidth >= n && c(d);
                    n += d.width
                }
            }
            a && (o.renderedColumns = i)
        }, p.prevScrollTop = 0, p.prevScrollIndex = 0, o.adjustScrollTop = function (e, r) {
            if (p.prevScrollTop !== e || r) {
                e > 0 && p.$viewport[0].scrollHeight - e <= p.$viewport.outerHeight() && o.$emit("ngGridEventScroll");
                var i, l = Math.floor(e / p.config.rowHeight);
                if (p.filteredRows.length > p.config.virtualizationThreshold) {
                    if (e > p.prevScrollTop && p.prevScrollIndex + t > l)return;
                    if (p.prevScrollTop > e && l > p.prevScrollIndex - t)return;
                    i = new ng.Range(Math.max(0, l - n), l + p.minRowsToRender() + n)
                } else {
                    var a = o.configGroups.length > 0 ? p.rowFactory.parsedData.length : p.data.length;
                    i = new ng.Range(0, Math.max(a, p.minRowsToRender() + n))
                }
                p.prevScrollTop = e, p.rowFactory.UpdateViewableRange(i), p.prevScrollIndex = l
            }
        }, o.toggleShowMenu = function () {
            o.showMenu = !o.showMenu
        }, o.toggleSelectAll = function (e) {
            o.selectionProvider.toggleSelectAll(e)
        }, o.totalFilteredItemsLength = function () {
            return p.filteredRows.length
        }, o.showGroupPanel = function () {
            return p.config.showGroupPanel
        }, o.topPanelHeight = function () {
            return p.config.showGroupPanel === !0 ? p.config.headerRowHeight + 32 : p.config.headerRowHeight
        }, o.viewportDimHeight = function () {
            return Math.max(0, p.rootDim.outerHeight - o.topPanelHeight() - o.footerRowHeight - 2)
        }, o.groupBy = function (e) {
            if (e.sortDirection || e.sort({shiftKey: !1}), !(1 > p.data.length) && e.groupable && e.field) {
                var n = o.configGroups.indexOf(e);
                -1 == n ? (e.isGroupedBy = !0, o.configGroups.push(e), e.groupIndex = o.configGroups.length) : o.removeGroup(n), p.$viewport.scrollTop(0), l.digest(o)
            }
        }, o.removeGroup = function (e) {
            var n = o.columns.filter(function (n) {
                return n.groupIndex == e + 1
            })[0];
            n.isGroupedBy = !1, n.groupIndex = 0, o.columns[e].isAggCol && (o.columns.splice(e, 1), o.configGroups.splice(e, 1), p.fixGroupIndexes()), 0 === o.configGroups.length && (p.fixColumnIndexes(), l.digest(o)), o.adjustScrollLeft(0)
        }, o.togglePin = function (e) {
            for (var n = e.index, t = 0, r = 0; o.columns.length > r && o.columns[r].pinned; r++)t++;
            e.pinned && (t = Math.max(e.originalIndex, t - 1)), e.pinned = !e.pinned, o.columns.splice(n, 1), o.columns.splice(t, 0, e), p.fixColumnIndexes(), l.BuildStyles(o, p, !0), p.$viewport.scrollLeft(p.$viewport.scrollLeft() - e.width)
        }, o.totalRowWidth = function () {
            for (var e = 0, n = o.columns, t = 0; n.length > t; t++)n[t].visible !== !1 && (e += n[t].width);
            return e
        }, o.headerScrollerDim = function () {
            var e = o.viewportDimHeight(), n = p.maxCanvasHt, t = n > e, r = new ng.Dimension;
            return r.autoFitHeight = !0, r.outerWidth = o.totalRowWidth(), t ? r.outerWidth += p.elementDims.scrollW : p.elementDims.scrollH >= n - e && (r.outerWidth += p.elementDims.scrollW), r
        }, p.init()
    }, ng.Range = function (e, n) {
        this.topRow = e, this.bottomRow = n
    }, ng.Row = function (e, n, t, o, r) {
        var i = this, l = n.enableRowSelection;
        i.jqueryUITheme = n.jqueryUITheme, i.rowClasses = n.rowClasses, i.entity = e, i.selectionProvider = t, i.selected = t.getSelection(e), i.cursor = l ? "pointer" : "default", i.setSelection = function (e) {
            i.selectionProvider.setSelection(i, e), i.selectionProvider.lastClickedRow = i
        }, i.continueSelection = function (e) {
            i.selectionProvider.ChangeSelection(i, e)
        }, i.ensureEntity = function (e) {
            i.entity != e && (i.entity = e, i.selected = i.selectionProvider.getSelection(i.entity))
        }, i.toggleSelected = function (e) {
            if (!l && !n.enableCellSelection)return!0;
            var t = e.target || e;
            return"checkbox" == t.type && "ngSelectionCell ng-scope" != t.parentElement.className ? !0 : n.selectWithCheckboxOnly && "checkbox" != t.type ? (i.selectionProvider.lastClickedRow = i, !0) : (i.beforeSelectionChange(i, e) && i.continueSelection(e), !1)
        }, i.rowIndex = o, i.offsetTop = i.rowIndex * n.rowHeight, i.rowDisplayIndex = 0, i.alternatingRowClass = function () {
            var e = 0 === i.rowIndex % 2, n = {selected: i.selected, "ui-state-default": i.jqueryUITheme && e, "ui-state-active": i.jqueryUITheme && !e, even: e, odd: !e};
            return n
        }, i.beforeSelectionChange = n.beforeSelectionChangeCallback, i.afterSelectionChange = n.afterSelectionChangeCallback, i.getProperty = function (e) {
            return r.evalProperty(i.entity, e)
        }, i.copy = function () {
            return i.clone = new ng.Row(e, n, t, o, r), i.clone.isClone = !0, i.clone.elm = i.elm, i.clone
        }, i.setVars = function (e) {
            e.clone = i, i.entity = e.entity, i.selected = e.selected
        }
    }, ng.RowFactory = function (e, t, o, r, c) {
        var g = this;
        g.aggCache = {}, g.parentCache = [], g.dataChanged = !0, g.parsedData = [], g.rowConfig = {}, g.selectionProvider = t.selectionProvider, g.rowHeight = 30, g.numberOfAggregates = 0, g.groupedData = void 0, g.rowHeight = e.config.rowHeight, g.rowConfig = {enableRowSelection: e.config.enableRowSelection, rowClasses: e.config.rowClasses, selectedItems: t.selectedItems, selectWithCheckboxOnly: e.config.selectWithCheckboxOnly, beforeSelectionChangeCallback: e.config.beforeSelectionChange, afterSelectionChangeCallback: e.config.afterSelectionChange, jqueryUITheme: e.config.jqueryUITheme, enableCellSelection: e.config.enableCellSelection, rowHeight: e.config.rowHeight}, g.renderedRange = new ng.Range(0, e.minRowsToRender() + n), g.buildEntityRow = function (e, n) {
            return new ng.Row(e, g.rowConfig, g.selectionProvider, n, c)
        }, g.buildAggregateRow = function (e, n) {
            var t = g.aggCache[e.aggIndex];
            return t || (t = new ng.Aggregate(e, g, g.rowConfig.rowHeight), g.aggCache[e.aggIndex] = t), t.rowIndex = n, t.offsetTop = n * g.rowConfig.rowHeight, t
        }, g.UpdateViewableRange = function (e) {
            g.renderedRange = e, g.renderedChange()
        }, g.filteredRowsChanged = function () {
            e.lateBoundColumns && e.filteredRows.length > 0 && (e.config.columnDefs = void 0, e.buildColumns(), e.lateBoundColumns = !1, t.$evalAsync(function () {
                t.adjustScrollLeft(0)
            })), g.dataChanged = !0, e.config.groups.length > 0 && g.getGrouping(e.config.groups), g.UpdateViewableRange(g.renderedRange)
        }, g.renderedChange = function () {
            if (!g.groupedData || 1 > e.config.groups.length)return g.renderedChangeNoGroups(), e.refreshDomSizes(), void 0;
            g.wasGrouped = !0, g.parentCache = [];
            var n = 0, t = g.parsedData.filter(function (e) {
                return e.isAggRow ? e.parent && e.parent.collapsed ? !1 : !0 : (e[a] || (e.rowIndex = n++), !e[a])
            });
            g.totalRows = t.length;
            for (var o = [], r = g.renderedRange.topRow; g.renderedRange.bottomRow > r; r++)t[r] && (t[r].offsetTop = r * e.config.rowHeight, o.push(t[r]));
            e.setRenderedRows(o)
        }, g.renderedChangeNoGroups = function () {
            for (var n = [], t = g.renderedRange.topRow; g.renderedRange.bottomRow > t; t++)e.filteredRows[t] && (e.filteredRows[t].rowIndex = t, e.filteredRows[t].offsetTop = t * e.config.rowHeight, n.push(e.filteredRows[t]));
            e.setRenderedRows(n)
        }, g.fixRowCache = function () {
            var n = e.data.length, t = n - e.rowCache.length;
            if (0 > t)e.rowCache.length = e.rowMap.length = n; else for (var o = e.rowCache.length; n > o; o++)e.rowCache[o] = e.rowFactory.buildEntityRow(e.data[o], o)
        }, g.parseGroupData = function (e) {
            if (e.values)for (var n = 0; e.values.length > n; n++)g.parentCache[g.parentCache.length - 1].children.push(e.values[n]), g.parsedData.push(e.values[n]); else for (var t in e)if (t != i && t != l && t != s && e.hasOwnProperty(t)) {
                var o = g.buildAggregateRow({gField: e[i], gLabel: t, gDepth: e[l], isAggRow: !0, _ng_hidden_: !1, children: [], aggChildren: [], aggIndex: g.numberOfAggregates, aggLabelFilter: e[s].aggLabelFilter}, 0);
                g.numberOfAggregates++, o.parent = g.parentCache[o.depth - 1], o.parent && (o.parent.collapsed = !1, o.parent.aggChildren.push(o)), g.parsedData.push(o), g.parentCache[o.depth] = o, g.parseGroupData(e[t])
            }
        }, g.getGrouping = function (n) {
            g.aggCache = [], g.numberOfAggregates = 0, g.groupedData = {};
            for (var d = e.filteredRows, u = n.length, f = t.columns, p = 0; d.length > p; p++) {
                var h = d[p].entity;
                if (!h)return;
                d[p][a] = !0;
                for (var m = g.groupedData, v = 0; n.length > v; v++) {
                    var w = n[v], C = f.filter(function (e) {
                        return e.field == w
                    })[0], b = c.evalProperty(h, w);
                    b = b ? "" + b : "null", m[b] || (m[b] = {}), m[i] || (m[i] = w), m[l] || (m[l] = v), m[s] || (m[s] = C), m = m[b]
                }
                m.values || (m.values = []), m.values.push(d[p])
            }
            for (var x = 0; n.length > x; x++)!f[x].isAggCol && u >= x && f.splice(0, 0, new ng.Column({colDef: {field: "", width: 25, sortable: !1, resizable: !1, headerCellTemplate: '<div class="ngAggHeader"></div>', pinned: e.config.pinSelectionCheckbox}, isAggCol: !0, headerRowHeight: e.config.headerRowHeight}, t, e, o, r, c));
            o.BuildStyles(t, e, !0), e.fixColumnIndexes(), t.adjustScrollLeft(0), g.parsedData.length = 0, g.parseGroupData(g.groupedData), g.fixRowCache()
        }, e.config.groups.length > 0 && e.filteredRows.length > 0 && g.getGrouping(e.config.groups)
    }, ng.SearchProvider = function (e, n, t) {
        var o = this, r = [];
        o.extFilter = n.config.filterOptions.useExternalFilter, e.showFilter = n.config.showFilter, e.filterText = "", o.fieldMap = {}, o.evalFilter = function () {
            var e = function (e) {
                for (var n = 0, l = r.length; l > n; n++) {
                    var a, s = r[n];
                    if (!s.column) {
                        for (var c in e)if (e.hasOwnProperty(c)) {
                            var g = o.fieldMap[c];
                            if (!g)continue;
                            var d = null, u = null;
                            g && g.cellFilter && (u = g.cellFilter.split(":"), d = t(u[0]));
                            var f = e[c];
                            if (null != f) {
                                if ("function" == typeof d) {
                                    var p = "" + d("object" == typeof f ? i(f, g.field) : f, u[1]);
                                    a = s.regex.test(p)
                                } else a = s.regex.test("object" == typeof f ? "" + i(f, g.field) : "" + f);
                                if (f && a)return!0
                            }
                        }
                        return!1
                    }
                    var h = o.fieldMap[s.columnDisplay];
                    if (!h)return!1;
                    var m = h.cellFilter.split(":"), v = h.cellFilter ? t(m[0]) : null, w = e[s.column] || e[h.field.split(".")[0]];
                    if (null == w)return!1;
                    if ("function" == typeof v) {
                        var C = "" + v("object" == typeof w ? i(w, h.field) : w, m[1]);
                        a = s.regex.test(C)
                    } else a = s.regex.test("object" == typeof w ? "" + i(w, h.field) : "" + w);
                    if (!w || !a)return!1
                }
                return!0
            };
            n.filteredRows = 0 === r.length ? n.rowCache : n.rowCache.filter(function (n) {
                return e(n.entity)
            });
            for (var l = 0; n.filteredRows.length > l; l++)n.filteredRows[l].rowIndex = l;
            n.rowFactory.filteredRowsChanged()
        };
        var i = function (e, n) {
            if ("object" != typeof e || "string" != typeof n)return e;
            var t = n.split("."), o = e;
            if (t.length > 1) {
                for (var r = 1, i = t.length; i > r; r++)if (o = o[t[r]], !o)return e;
                return o
            }
            return e
        }, l = function (e, n) {
            try {
                return RegExp(e, n)
            } catch (t) {
                return RegExp(e.replace(/(\^|\$|\(|\)|\<|\>|\[|\]|\{|\}|\\|\||\.|\*|\+|\?)/g, "\\$1"))
            }
        }, a = function (e) {
            r = [];
            var n;
            if (n = $.trim(e))for (var t = n.split(";"), o = 0; t.length > o; o++) {
                var i = t[o].split(":");
                if (i.length > 1) {
                    var a = $.trim(i[0]), s = $.trim(i[1]);
                    a && s && r.push({column: a, columnDisplay: a.replace(/\s+/g, "").toLowerCase(), regex: l(s, "i")})
                } else {
                    var c = $.trim(i[0]);
                    c && r.push({column: "", regex: l(c, "i")})
                }
            }
        };
        e.$watch(n.config.filterOptions.filterText, function (n) {
            e.filterText = n
        }), e.$watch("filterText", function (n) {
            o.extFilter || (e.$emit("ngGridEventFilter", n), a(n), o.evalFilter())
        }), o.extFilter || e.$watch("columns", function (e) {
            for (var n = 0; e.length > n; n++) {
                var t = e[n];
                t.field && (o.fieldMap[t.field.split(".")[0]] = t), t.displayName && (o.fieldMap[t.displayName.toLowerCase().replace(/\s+/g, "")] = t)
            }
        })
    }, ng.selectionProvider = function (e, n) {
        var t = this;
        t.multi = e.config.multiSelect, t.selectedItems = e.config.selectedItems, t.selectedIndex = e.config.selectedIndex, t.lastClickedRow = void 0, t.ignoreSelectedItemChanges = !1, t.ChangeSelection = function (o, r) {
            var i = o.isClone ? e.filteredRows[o.rowIndex] : o;
            if (r && r.shiftKey && !r.keyCode && t.multi && e.config.enableRowSelection) {
                if (t.lastClickedRow) {
                    var l;
                    l = n.configGroups.length > 0 ? e.rowFactory.parsedData.filter(function (e) {
                        return!e.isAggRow
                    }) : e.filteredRows;
                    var a = i.rowIndex, s = t.lastClickedRow.rowIndex;
                    if (t.lastClickedRow = i, a == s)return!1;
                    s > a ? (a ^= s, s = a ^ s, a ^= s, a--) : s++;
                    for (var c = []; a >= s; s++)c.push(l[s]);
                    if (c[c.length - 1].beforeSelectionChange(c, r)) {
                        for (var g = 0; c.length > g; g++) {
                            var d = c[g], u = d.selected;
                            d.selected = !u, d.clone && (d.clone.selected = d.selected);
                            var f = t.selectedItems.indexOf(d.entity);
                            -1 === f ? t.selectedItems.push(d.entity) : t.selectedItems.splice(f, 1)
                        }
                        c[c.length - 1].afterSelectionChange(c, r)
                    }
                    return!0
                }
            } else t.multi ? r.keyCode || t.setSelection(i, !i.selected) : t.lastClickedRow == i ? t.setSelection(t.lastClickedRow, e.config.keepLastSelected ? !0 : !i.selected) : (t.lastClickedRow && t.setSelection(t.lastClickedRow, !1), t.setSelection(i, !i.selected));
            return t.lastClickedRow = i, !0
        }, t.getSelection = function (e) {
            return-1 !== t.selectedItems.indexOf(e)
        }, t.setSelection = function (n, o) {
            var r = n.isClone ? e.filteredRows[n.rowIndex] : n;
            if (e.config.enableRowSelection) {
                if (r.selected = o, r.clone && (r.clone.selected = o), o)-1 === t.selectedItems.indexOf(r.entity) && (!t.multi && t.selectedItems.length > 0 && (t.toggleSelectAll(!1, !0), r.selected = o, r.clone && (r.clone.selected = o)), t.selectedItems.push(r.entity)); else {
                    var i = t.selectedItems.indexOf(r.entity);
                    -1 != i && t.selectedItems.splice(i, 1)
                }
                r.afterSelectionChange(r)
            }
        }, t.toggleSelectAll = function (n, o) {
            if (o || e.config.beforeSelectionChange(e.filteredRows)) {
                var r = t.selectedItems.length;
                r > 0 && (t.selectedItems.length = 0);
                for (var i = 0; e.filteredRows.length > i; i++)e.filteredRows[i].selected = n, e.filteredRows[i].clone && (e.filteredRows[i].clone.selected = n), n && t.selectedItems.push(e.filteredRows[i].entity);
                o || e.config.afterSelectionChange(e.filteredRows)
            }
        }
    }, ng.StyleProvider = function (e, n, t) {
        e.headerCellStyle = function (e) {
            return{height: e.headerRowHeight + "px"}
        }, e.rowStyle = function (n) {
            return{top: n.offsetTop + "px", height: e.rowHeight + "px"}
        }, e.canvasStyle = function () {
            return{height: "" + n.maxCanvasHt + "px"}
        }, e.headerScrollerStyle = function () {
            return{height: n.config.headerRowHeight + "px"}
        }, e.topPanelStyle = function () {
            return{width: n.rootDim.outerWidth + "px", height: e.topPanelHeight() + "px"}
        }, e.headerStyle = function () {
            return{width: n.rootDim.outerWidth - t.ScrollW + "px", height: n.config.headerRowHeight + "px"}
        }, e.groupPanelStyle = function () {
            return{width: n.rootDim.outerWidth - t.ScrollW + "px", height: "32px"}
        }, e.viewportStyle = function () {
            return{width: n.rootDim.outerWidth + "px", height: e.viewportDimHeight() + "px"}
        }, e.footerStyle = function () {
            return{width: n.rootDim.outerWidth + "px", height: e.footerRowHeight + "px"}
        }
    }, h.directive("ngCellHasFocus", ["$domUtilityService", function (e) {
        var n = function (n, t) {
            n.isFocused = !0, e.digest(n);
            var o = angular.element(t[0].children).filter(function () {
                return 8 != this.nodeType
            }), r = angular.element(o[0].children[0]);
            r.length > 0 && (angular.element(r).focus(), n.domAccessProvider.selectInputElement(r[0]), angular.element(r).bind("blur", function () {
                return n.isFocused = !1, e.digest(n), !0
            }))
        };
        return function (e, t) {
            var o = !1;
            e.editCell = function () {
                setTimeout(function () {
                    n(e, t)
                }, 0)
            }, t.bind("mousedown", function () {
                return t.focus(), !0
            }), t.bind("focus", function () {
                return o = !0, !0
            }), t.bind("blur", function () {
                return o = !1, !0
            }), t.bind("keydown", function (r) {
                return o && 37 != r.keyCode && 38 != r.keyCode && 39 != r.keyCode && 40 != r.keyCode && 9 != r.keyCode && !r.shiftKey && 13 != r.keyCode && n(e, t), 27 == r.keyCode && t.focus(), !0
            })
        }
    }]), h.directive("ngCellText", function () {
        return function (e, n) {
            n.bind("mouseover", function (e) {
                e.preventDefault(), n.css({cursor: "text"})
            }), n.bind("mouseleave", function (e) {
                e.preventDefault(), n.css({cursor: "default"})
            })
        }
    }), h.directive("ngCell", ["$compile", "$domUtilityService", function (e, n) {
        var t = {scope: !1, compile: function () {
            return{pre: function (n, t) {
                var o, r = n.col.cellTemplate.replace(g, "$eval('row.entity.' + col.field)");
                n.col.enableCellEdit ? (o = n.col.cellEditTemplate, o = o.replace(d, r), o = o.replace(u, n.col.editableCellTemplate.replace(g, "col.field"))) : o = r;
                var i = e(o)(n);
                n.enableCellSelection && -1 == i[0].className.indexOf("ngSelectionCell") && (i[0].setAttribute("tabindex", 0), i.addClass("ngCellElement")), t.append(i)
            }, post: function (e, t) {
                e.enableCellSelection && e.domAccessProvider.selectionHandlers(e, t), e.$on("ngGridEventDigestCell", function () {
                    n.digest(e)
                })
            }}
        }};
        return t
    }]), h.directive("ngGrid", ["$compile", "$filter", "$templateCache", "$sortService", "$domUtilityService", "$utilityService", "$timeout", function (e, n, t, o, r, i, l) {
        var a = {scope: !0, compile: function () {
            return{pre: function (a, s, c) {
                var g = $(s), d = a.$eval(c.ngGrid);
                d.gridDim = new ng.Dimension({outerHeight: $(g).height(), outerWidth: $(g).width()});
                var u = new ng.Grid(a, d, o, r, n, t, i, l);
                if ("string" == typeof d.columnDefs ? a.$parent.$watch(d.columnDefs, function (e) {
                    return e ? (a.columns = [], u.config.columnDefs = e, u.buildColumns(), u.configureColumnWidths(), u.eventProvider.assignEvents(), r.RebuildGrid(a, u), void 0) : (u.refreshDomSizes(), u.buildColumns(), void 0)
                }) : u.buildColumns(), "string" == typeof d.data) {
                    var f = function (e) {
                        u.data = $.extend([], e), u.rowFactory.fixRowCache(), angular.forEach(u.data, function (e, n) {
                            var t = u.rowMap[n] || n;
                            u.rowCache[t] && u.rowCache[t].ensureEntity(e), u.rowMap[t] = n
                        }), u.searchProvider.evalFilter(), u.configureColumnWidths(), u.refreshDomSizes(), u.config.sortInfo.fields.length > 0 && o.sortData(u.config.sortInfo, u.data.slice(0)), a.$emit("ngGridEventData", u.gridId)
                    };
                    a.$parent.$watch(d.data, f), a.$parent.$watch(d.data + ".length", function () {
                        f(a.$eval(d.data))
                    })
                }
                return u.footerController = new ng.Footer(a, u), s.addClass("ngGrid").addClass("" + u.gridId), d.jqueryUITheme && s.addClass("ui-widget"), s.append(e(t.get("gridTemplate.html"))(a)), r.AssignGridContainers(a, s, u), u.eventProvider = new ng.EventProvider(u, a, r), angular.forEach(d.plugins, function (e) {
                    "function" == typeof e ? e.call(this, []).init(a.$new(), u, {SortService: o, DomUtilityService: r}) : e.init(a.$new(), u, {SortService: o, DomUtilityService: r})
                }), d.selectRow = function (e, n) {
                    u.rowCache[e] && u.rowCache[e].setSelection(n ? !0 : !1)
                }, d.selectItem = function (e, n) {
                    d.selectRow(u.rowMap[e], n)
                }, d.selectAll = function (e) {
                    a.toggleSelectAll(e)
                }, d.groupBy = function (e) {
                    if (e)a.groupBy(a.columns.filter(function (n) {
                        return n.field == e
                    })[0]); else {
                        var n = $.extend(!0, [], a.configGroups);
                        angular.forEach(n, a.groupBy)
                    }
                }, d.sortBy = function (e) {
                    var n = a.columns.filter(function (n) {
                        return n.field == e
                    })[0];
                    n && n.sort()
                }, d.gridId = u.gridId, d.ngGrid = u, d.$gridScope = a, a.$on("ngGridEventDigestGrid", function () {
                    r.digest(a.$parent)
                }), a.$on("ngGridEventDigestGridParent", function () {
                    r.digest(a.$parent)
                }), a.$evalAsync(function () {
                    a.adjustScrollLeft(0)
                }), null
            }}
        }};
        return a
    }]), h.directive("ngHeaderCell", ["$compile", function (e) {
        var n = {scope: !1, compile: function () {
            return{pre: function (n, t) {
                t.append(e(n.col.headerCellTemplate)(n))
            }}
        }};
        return n
    }]), h.directive("ngHeaderRow", ["$compile", "$templateCache", function (e, n) {
        var t = {scope: !1, compile: function () {
            return{pre: function (t, o) {
                0 === o.children().length && o.append(e(n.get(t.gridId + "headerRowTemplate.html"))(t))
            }}
        }};
        return t
    }]), h.directive("ngIf", [function () {
        return{transclude: "element", priority: 1e3, terminal: !0, restrict: "A", compile: function (e, n, t) {
            return function (e, n, o) {
                var r, i;
                e.$watch(o.ngIf, function (o) {
                    r && (r.remove(), r = void 0), i && (i.$destroy(), i = void 0), o && (i = e.$new(), t(i, function (e) {
                        r = e, n.after(e)
                    }))
                })
            }
        }}
    }]), h.directive("ngInput", ["$parse", function (e) {
        return function (n, t, o) {
            var r = e(n.$eval(o.ngInput)), i = r.assign, l = r(n.row.entity);
            t.val(l), t.bind("keyup", function () {
                var e = t.val();
                n.$root.$$phase || n.$apply(function () {
                    i(n.row.entity, e)
                })
            }), t.bind("keydown", function (e) {
                switch (e.keyCode) {
                    case 37:
                    case 38:
                    case 39:
                    case 40:
                        e.stopPropagation();
                        break;
                    case 27:
                        n.$root.$$phase || n.$apply(function () {
                            i(n.row.entity, l), t.val(l), t.blur()
                        });
                    default:
                }
                return!0
            })
        }
    }]), h.directive("ngRow", ["$compile", "$domUtilityService", "$templateCache", function (e, n, t) {
        var o = {scope: !1, compile: function () {
            return{pre: function (o, r) {
                if (o.row.elm = r, o.row.clone && (o.row.clone.elm = r), o.row.isAggRow) {
                    var i = t.get(o.gridId + "aggregateTemplate.html");
                    i = o.row.aggLabelFilter ? i.replace(c, "| " + o.row.aggLabelFilter) : i.replace(c, ""), r.append(e(i)(o))
                } else r.append(e(t.get(o.gridId + "rowTemplate.html"))(o));
                o.$on("ngGridEventDigestRow", function () {
                    n.digest(o)
                })
            }}
        }};
        return o
    }]), h.directive("ngViewport", [function () {
        return function (e, n) {
            var t, o, r = 0;
            n.bind("scroll", function (n) {
                var i = n.target.scrollLeft, l = n.target.scrollTop;
                return e.$headerContainer && e.$headerContainer.scrollLeft(i), e.adjustScrollLeft(i), e.adjustScrollTop(l), e.$root.$$phase || e.$digest(), o = i, r = r, t = !1, !0
            }), n.bind("mousewheel DOMMouseScroll", function () {
                return t = !0, n.focus(), !0
            }), e.enableCellSelection || e.domAccessProvider.selectionHandlers(e, n)
        }
    }]), e.ngGrid.i18n.en = {ngAggregateLabel: "items", ngGroupPanelDescription: "Drag a column header here and drop it to group by that column.", ngSearchPlaceHolder: "Search...", ngMenuText: "Choose Columns:", ngShowingItemsLabel: "Showing Items:", ngTotalItemsLabel: "Total Items:", ngSelectedItemsLabel: "Selected Items:", ngPageSizeLabel: "Page Size:", ngPagerFirstTitle: "First Page", ngPagerNextTitle: "Next Page", ngPagerPrevTitle: "Previous Page", ngPagerLastTitle: "Last Page"}, e.ngGrid.i18n.fr = {ngAggregateLabel: "articles", ngGroupPanelDescription: "Faites glisser un en-tête de colonne ici et déposez-le vers un groupe par cette colonne.", ngSearchPlaceHolder: "Recherche...", ngMenuText: "Choisir des colonnes:", ngShowingItemsLabel: "Articles Affichage des:", ngTotalItemsLabel: "Nombre total d'articles:", ngSelectedItemsLabel: "Éléments Articles:", ngPageSizeLabel: "Taille de page:", ngPagerFirstTitle: "Première page", ngPagerNextTitle: "Page Suivante", ngPagerPrevTitle: "Page précédente", ngPagerLastTitle: "Dernière page"}, e.ngGrid.i18n.ge = {ngAggregateLabel: "artikel", ngGroupPanelDescription: "Ziehen Sie eine Spaltenüberschrift hier und legen Sie es der Gruppe nach dieser Spalte.", ngSearchPlaceHolder: "Suche...", ngMenuText: "Spalten auswählen:", ngShowingItemsLabel: "Zeige Artikel:", ngTotalItemsLabel: "Meiste Artikel:", ngSelectedItemsLabel: "Ausgewählte Artikel:", ngPageSizeLabel: "Größe Seite:", ngPagerFirstTitle: "Erste Page", ngPagerNextTitle: "Nächste Page", ngPagerPrevTitle: "Vorherige Page", ngPagerLastTitle: "Letzte Page"}, e.ngGrid.i18n.sp = {ngAggregateLabel: "Artículos", ngGroupPanelDescription: "Arrastre un encabezado de columna aquí y soltarlo para agrupar por esa columna.", ngSearchPlaceHolder: "Buscar...", ngMenuText: "Elegir columnas:", ngShowingItemsLabel: "Artículos Mostrando:", ngTotalItemsLabel: "Artículos Totales:", ngSelectedItemsLabel: "Artículos Seleccionados:", ngPageSizeLabel: "Tamaño de Página:", ngPagerFirstTitle: "Primera Página", ngPagerNextTitle: "Página Siguiente", ngPagerPrevTitle: "Página Anterior", ngPagerLastTitle: "Última Página"}, e.ngGrid.i18n["zh-cn"] = {ngAggregateLabel: "条目", ngGroupPanelDescription: "拖曳表头到此处以进行分组", ngSearchPlaceHolder: "搜索...", ngMenuText: "数据分组与选择列：", ngShowingItemsLabel: "当前显示条目：", ngTotalItemsLabel: "条目总数：", ngSelectedItemsLabel: "选中条目：", ngPageSizeLabel: "每页显示数：", ngPagerFirstTitle: "回到首页", ngPagerNextTitle: "下一页", ngPagerPrevTitle: "上一页", ngPagerLastTitle: "前往尾页"}, angular.module("ngGrid").run(["$templateCache", function (e) {
        e.put("aggregateTemplate.html", '<div ng-click="row.toggleExpand()" ng-style="{\'left\': row.offsetleft}" class="ngAggregate">    <span class="ngAggregateText">{{row.label CUSTOM_FILTERS}} ({{row.totalChildren()}} {{AggItemsLabel}})</span>    <div class="{{row.aggClass()}}"></div></div>'), e.put("cellEditTemplate.html", '<div ng-cell-has-focus ng-dblclick="editCell()">	<div ng-if="!isFocused">	DISPLAY_CELL_TEMPLATE	</div>	<div ng-if="isFocused">	EDITABLE_CELL_TEMPLATE	</div></div>'), e.put("cellTemplate.html", '<div class="ngCellText" ng-class="col.colIndex()"><span ng-cell-text>{{COL_FIELD CUSTOM_FILTERS}}</span></div>'), e.put("checkboxCellTemplate.html", '<div class="ngSelectionCell"><input tabindex="-1" class="ngSelectionCheckbox" type="checkbox" ng-checked="row.selected" /></div>'), e.put("checkboxHeaderTemplate.html", '<input class="ngSelectionHeader" type="checkbox" ng-show="multiSelect" ng-model="allSelected" ng-change="toggleSelectAll(allSelected)"/>'), e.put("editableCellTemplate.html", '<input ng-class="\'colt\' + col.index" ng-input="COL_FIELD" />'), e.put("gridTemplate.html", '<div class="ngTopPanel" ng-class="{\'ui-widget-header\':jqueryUITheme, \'ui-corner-top\': jqueryUITheme}" ng-style="topPanelStyle()">    <div class="ngGroupPanel" ng-show="showGroupPanel()" ng-style="groupPanelStyle()">        <div class="ngGroupPanelDescription" ng-show="configGroups.length == 0">{{i18n.ngGroupPanelDescription}}</div>        <ul ng-show="configGroups.length > 0" class="ngGroupList">            <li class="ngGroupItem" ng-repeat="group in configGroups">                <span class="ngGroupElement">                    <span class="ngGroupName">{{group.displayName}}                        <span ng-click="removeGroup($index)" class="ngRemoveGroup">x</span>                    </span>                    <span ng-hide="$last" class="ngGroupArrow"></span>                </span>            </li>        </ul>    </div>    <div class="ngHeaderContainer" ng-style="headerStyle()">        <div class="ngHeaderScroller" ng-style="headerScrollerStyle()" ng-header-row></div>    </div>    <div class="ngHeaderButton" ng-show="showColumnMenu || showFilter" ng-click="toggleShowMenu()">        <div class="ngHeaderButtonArrow" ng-click=""></div>    </div>    <div ng-show="showMenu" class="ngColMenu">        <div ng-show="showFilter">            <input placeholder="{{i18n.ngSearchPlaceHolder}}" type="text" ng-model="filterText"/>        </div>        <div ng-show="showColumnMenu">            <span class="ngMenuText">{{i18n.ngMenuText}}</span>            <ul class="ngColList">                <li class="ngColListItem" ng-repeat="col in columns | ngColumns">                    <label><input ng-disabled="col.pinned" type="checkbox" class="ngColListCheckbox" ng-model="col.visible"/>{{col.displayName}}</label>					<a title="Group By" ng-class="col.groupedByClass()" ng-show="col.groupable && col.visible" ng-click="groupBy(col)"></a>					<span class="ngGroupingNumber" ng-show="col.groupIndex > 0">{{col.groupIndex}}</span>                          </li>            </ul>        </div>    </div></div><div class="ngViewport" unselectable="on" ng-viewport ng-class="{\'ui-widget-content\': jqueryUITheme}" ng-style="viewportStyle()">    <div class="ngCanvas" ng-style="canvasStyle()">        <div ng-style="rowStyle(row)" ng-repeat="row in renderedRows" ng-click="row.toggleSelected($event)" class="ngRow" ng-class="row.alternatingRowClass()" ng-row></div>    </div></div><div class="ngFooterPanel" ng-class="{\'ui-widget-content\': jqueryUITheme, \'ui-corner-bottom\': jqueryUITheme}" ng-style="footerStyle()">    <div class="ngTotalSelectContainer" ng-show="showFooter">        <div class="ngFooterTotalItems" ng-class="{\'ngNoMultiSelect\': !multiSelect}" >            <span class="ngLabel">{{i18n.ngTotalItemsLabel}} {{maxRows()}}</span><span ng-show="filterText.length > 0" class="ngLabel">({{i18n.ngShowingItemsLabel}} {{totalFilteredItemsLength()}})</span>        </div>        <div class="ngFooterSelectedItems" ng-show="multiSelect">            <span class="ngLabel">{{i18n.ngSelectedItemsLabel}} {{selectedItems.length}}</span>        </div>    </div>    <div class="ngPagerContainer" style="float: right; margin-top: 10px;" ng-show="showFooter && enablePaging" ng-class="{\'ngNoMultiSelect\': !multiSelect}">        <div style="float:left; margin-right: 10px;" class="ngRowCountPicker">            <span style="float: left; margin-top: 3px;" class="ngLabel">{{i18n.ngPageSizeLabel}}</span>            <select style="float: left;height: 27px; width: 100px" ng-model="pagingOptions.pageSize" >                <option ng-repeat="size in pagingOptions.pageSizes">{{size}}</option>            </select>        </div>        <div style="float:left; margin-right: 10px; line-height:25px;" class="ngPagerControl" style="float: left; min-width: 135px;">            <button class="ngPagerButton" ng-click="pageToFirst()" ng-disabled="cantPageBackward()" title="{{i18n.ngPagerFirstTitle}}"><div class="ngPagerFirstTriangle"><div class="ngPagerFirstBar"></div></div></button>            <button class="ngPagerButton" ng-click="pageBackward()" ng-disabled="cantPageBackward()" title="{{i18n.ngPagerPrevTitle}}"><div class="ngPagerFirstTriangle ngPagerPrevTriangle"></div></button>            <input class="ngPagerCurrent" type="number" style="width:50px; height: 24px; margin-top: 1px; padding: 0px 4px;" ng-model="pagingOptions.currentPage"/>            <button class="ngPagerButton" ng-click="pageForward()" ng-disabled="cantPageForward()" title="{{i18n.ngPagerNextTitle}}"><div class="ngPagerLastTriangle ngPagerNextTriangle"></div></button>            <button class="ngPagerButton" ng-click="pageToLast()" ng-disabled="cantPageToLast()" title="{{i18n.ngPagerLastTitle}}"><div class="ngPagerLastTriangle"><div class="ngPagerLastBar"></div></div></button>        </div>    </div></div>'), e.put("headerCellTemplate.html", '<div class="ngHeaderSortColumn {{col.headerClass}}" ng-style="{\'cursor\': col.cursor}" ng-class="{ \'ngSorted\': !noSortVisible }">    <div ng-click="col.sort($event)" ng-class="\'colt\' + col.index" class="ngHeaderText">{{col.displayName}}</div>    <div class="ngSortButtonDown" ng-show="col.showSortButtonDown()"></div>    <div class="ngSortButtonUp" ng-show="col.showSortButtonUp()"></div>    <div class="ngSortPriority">{{col.sortPriority}}</div>    <div ng-class="{ ngPinnedIcon: col.pinned, ngUnPinnedIcon: !col.pinned }" ng-click="togglePin(col)" ng-show="col.pinnable"></div></div><div ng-show="col.resizable" class="ngHeaderGrip" ng-click="col.gripClick($event)" ng-mousedown="col.gripOnMouseDown($event)"></div>'), e.put("headerRowTemplate.html", '<div ng-style="{\'z-index\': col.zIndex(), height: col.headerRowHeight}" ng-repeat="col in renderedColumns" ng-class="col.colIndex()" class="ngHeaderCell" ng-header-cell></div>'), e.put("rowTemplate.html", '<div ng-style="{\'cursor\': row.cursor, \'z-index\': col.zIndex() }" ng-repeat="col in renderedColumns" ng-class="col.colIndex()" class="ngCell {{col.cellClass}}" ng-cell></div>')
    }])
})(window);